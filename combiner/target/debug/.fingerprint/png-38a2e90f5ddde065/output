{"message":"`if` is not allowed in a `const fn`","code":{"code":"E0658","explanation":"An unstable feature was used.\n\nErroneous code example:\n\n```compile_fail,E658\n#[repr(u128)] // error: use of unstable library feature 'repr128'\nenum Foo {\n    Bar(u64),\n}\n```\n\nIf you're using a stable or a beta version of rustc, you won't be able to use\nany unstable features. In order to do so, please switch to a nightly version of\nrustc (by using rustup).\n\nIf you're using a nightly version of rustc, just add the corresponding feature\nto be able to use it:\n\n```\n#![feature(repr128)]\n\n#[repr(u128)] // ok!\nenum Foo {\n    Bar(u64),\n}\n```\n"},"level":"error","spans":[{"file_name":"/home/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs","byte_start":17698,"byte_end":17906,"line_start":553,"line_end":557,"column_start":17,"column_end":18,"is_primary":true,"text":[{"text":"                if (bits & !Self::all().bits()) == 0 {","highlight_start":17,"highlight_end":55},{"text":"                    $crate::_core::option::Option::Some(Self { bits })","highlight_start":1,"highlight_end":71},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    $crate::_core::option::Option::None","highlight_start":1,"highlight_end":56},{"text":"                }","highlight_start":1,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs","byte_start":11525,"byte_end":11713,"line_start":368,"line_end":375,"column_start":9,"column_end":10,"is_primary":false,"text":[{"text":"        __impl_bitflags! {","highlight_start":9,"highlight_end":27},{"text":"            $BitFlags: $T {","highlight_start":1,"highlight_end":28},{"text":"                $(","highlight_start":1,"highlight_end":19},{"text":"                    $(#[$inner $($args)*])*","highlight_start":1,"highlight_end":44},{"text":"                    $Flag = $value;","highlight_start":1,"highlight_end":36},{"text":"                )*","highlight_start":1,"highlight_end":19},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/png-0.16.8/src/common.rs","byte_start":12259,"byte_end":14230,"line_start":409,"line_end":447,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"bitflags! {","highlight_start":1,"highlight_end":12},{"text":"    /// # Output transformations","highlight_start":1,"highlight_end":33},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Only `IDENTITY` and `TRANSFORM_EXPAND | TRANSFORM_STRIP_ALPHA` can be used at the moment.","highlight_start":1,"highlight_end":98},{"text":"    pub struct Transformations: u32 {","highlight_start":1,"highlight_end":38},{"text":"        /// No transformation","highlight_start":1,"highlight_end":30},{"text":"        const IDENTITY            = 0x0000; // read and write */","highlight_start":1,"highlight_end":65},{"text":"        /// Strip 16-bit samples to 8 bits","highlight_start":1,"highlight_end":43},{"text":"        const STRIP_16            = 0x0001; // read only */","highlight_start":1,"highlight_end":60},{"text":"        /// Discard the alpha channel","highlight_start":1,"highlight_end":38},{"text":"        const STRIP_ALPHA         = 0x0002; // read only */","highlight_start":1,"highlight_end":60},{"text":"        /// Expand 1; 2 and 4-bit samples to bytes","highlight_start":1,"highlight_end":51},{"text":"        const PACKING             = 0x0004; // read and write */","highlight_start":1,"highlight_end":65},{"text":"        /// Change order of packed pixels to LSB first","highlight_start":1,"highlight_end":55},{"text":"        const PACKSWAP            = 0x0008; // read and write */","highlight_start":1,"highlight_end":65},{"text":"        /// Expand paletted images to RGB; expand grayscale images of","highlight_start":1,"highlight_end":70},{"text":"        /// less than 8-bit depth to 8-bit depth; and expand tRNS chunks","highlight_start":1,"highlight_end":73},{"text":"        /// to alpha channels.","highlight_start":1,"highlight_end":31},{"text":"        const EXPAND              = 0x0010; // read only */","highlight_start":1,"highlight_end":60},{"text":"        /// Invert monochrome images","highlight_start":1,"highlight_end":37},{"text":"        const INVERT_MONO         = 0x0020; // read and write */","highlight_start":1,"highlight_end":65},{"text":"        /// Normalize pixels to the sBIT depth","highlight_start":1,"highlight_end":47},{"text":"        const SHIFT               = 0x0040; // read and write */","highlight_start":1,"highlight_end":65},{"text":"        /// Flip RGB to BGR; RGBA to BGRA","highlight_start":1,"highlight_end":42},{"text":"        const BGR                 = 0x0080; // read and write */","highlight_start":1,"highlight_end":65},{"text":"        /// Flip RGBA to ARGB or GA to AG","highlight_start":1,"highlight_end":42},{"text":"        const SWAP_ALPHA          = 0x0100; // read and write */","highlight_start":1,"highlight_end":65},{"text":"        /// Byte-swap 16-bit samples","highlight_start":1,"highlight_end":37},{"text":"        const SWAP_ENDIAN         = 0x0200; // read and write */","highlight_start":1,"highlight_end":65},{"text":"        /// Change alpha from opacity to transparency","highlight_start":1,"highlight_end":54},{"text":"        const INVERT_ALPHA        = 0x0400; // read and write */","highlight_start":1,"highlight_end":65},{"text":"        const STRIP_FILLER        = 0x0800; // write only */","highlight_start":1,"highlight_end":61},{"text":"        const STRIP_FILLER_BEFORE = 0x0800; // write only","highlight_start":1,"highlight_end":58},{"text":"        const STRIP_FILLER_AFTER  = 0x1000; // write only */","highlight_start":1,"highlight_end":61},{"text":"        const GRAY_TO_RGB         = 0x2000; // read only */","highlight_start":1,"highlight_end":60},{"text":"        const EXPAND_16           = 0x4000; // read only */","highlight_start":1,"highlight_end":60},{"text":"        const SCALE_16            = 0x8000; // read only */","highlight_start":1,"highlight_end":60},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"bitflags!","def_site_span":{"file_name":"/home/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs","byte_start":11087,"byte_end":11786,"line_start":350,"line_end":382,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! bitflags {","highlight_start":1,"highlight_end":1},{"text":"    (","highlight_start":1,"highlight_end":1},{"text":"        $(#[$outer:meta])*","highlight_start":1,"highlight_end":1},{"text":"        $vis:vis struct $BitFlags:ident: $T:ty {","highlight_start":1,"highlight_end":1},{"text":"            $(","highlight_start":1,"highlight_end":1},{"text":"                $(#[$inner:ident $($args:tt)*])*","highlight_start":1,"highlight_end":1},{"text":"                const $Flag:ident = $value:expr;","highlight_start":1,"highlight_end":1},{"text":"            )*","highlight_start":1,"highlight_end":1},{"text":"        }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        $($t:tt)*","highlight_start":1,"highlight_end":1},{"text":"    ) => {","highlight_start":1,"highlight_end":1},{"text":"        $(#[$outer])*","highlight_start":1,"highlight_end":1},{"text":"        #[derive(Copy, PartialEq, Eq, Clone, PartialOrd, Ord, Hash)]","highlight_start":1,"highlight_end":1},{"text":"        $vis struct $BitFlags {","highlight_start":1,"highlight_end":1},{"text":"            bits: $T,","highlight_start":1,"highlight_end":1},{"text":"        }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        __impl_bitflags! {","highlight_start":1,"highlight_end":1},{"text":"            $BitFlags: $T {","highlight_start":1,"highlight_end":1},{"text":"                $(","highlight_start":1,"highlight_end":1},{"text":"                    $(#[$inner $($args)*])*","highlight_start":1,"highlight_end":1},{"text":"                    $Flag = $value;","highlight_start":1,"highlight_end":1},{"text":"                )*","highlight_start":1,"highlight_end":1},{"text":"            }","highlight_start":1,"highlight_end":1},{"text":"        }","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        bitflags! {","highlight_start":1,"highlight_end":1},{"text":"            $($t)*","highlight_start":1,"highlight_end":1},{"text":"        }","highlight_start":1,"highlight_end":1},{"text":"    };","highlight_start":1,"highlight_end":1},{"text":"    () => {};","highlight_start":1,"highlight_end":1},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"__impl_bitflags!","def_site_span":{"file_name":"/home/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/bitflags-1.3.2/src/lib.rs","byte_start":12812,"byte_end":30941,"line_start":424,"line_end":932,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! __impl_bitflags {","highlight_start":1,"highlight_end":31},{"text":"    (","highlight_start":1,"highlight_end":6},{"text":"        $BitFlags:ident: $T:ty {","highlight_start":1,"highlight_end":33},{"text":"            $(","highlight_start":1,"highlight_end":15},{"text":"                $(#[$attr:ident $($args:tt)*])*","highlight_start":1,"highlight_end":48},{"text":"                $Flag:ident = $value:expr;","highlight_start":1,"highlight_end":43},{"text":"            )*","highlight_start":1,"highlight_end":15},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    ) => {","highlight_start":1,"highlight_end":11},{"text":"        impl $crate::_core::fmt::Debug for $BitFlags {","highlight_start":1,"highlight_end":55},{"text":"            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {","highlight_start":1,"highlight_end":97},{"text":"                // This convoluted approach is to handle #[cfg]-based flag","highlight_start":1,"highlight_end":75},{"text":"                // omission correctly. For example it needs to support:","highlight_start":1,"highlight_end":72},{"text":"                //","highlight_start":1,"highlight_end":19},{"text":"                //    #[cfg(unix)] const A: Flag = /* ... */;","highlight_start":1,"highlight_end":62},{"text":"                //    #[cfg(windows)] const B: Flag = /* ... */;","highlight_start":1,"highlight_end":65},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // Unconditionally define a check for every flag, even disabled","highlight_start":1,"highlight_end":80},{"text":"                // ones.","highlight_start":1,"highlight_end":25},{"text":"                #[allow(non_snake_case)]","highlight_start":1,"highlight_end":41},{"text":"                trait __BitFlags {","highlight_start":1,"highlight_end":35},{"text":"                    $(","highlight_start":1,"highlight_end":23},{"text":"                        #[inline]","highlight_start":1,"highlight_end":34},{"text":"                        fn $Flag(&self) -> bool { false }","highlight_start":1,"highlight_end":58},{"text":"                    )*","highlight_start":1,"highlight_end":23},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // Conditionally override the check for just those flags that","highlight_start":1,"highlight_end":78},{"text":"                // are not #[cfg]ed away.","highlight_start":1,"highlight_end":42},{"text":"                #[allow(non_snake_case)]","highlight_start":1,"highlight_end":41},{"text":"                impl __BitFlags for $BitFlags {","highlight_start":1,"highlight_end":48},{"text":"                    $(","highlight_start":1,"highlight_end":23},{"text":"                        __impl_bitflags! {","highlight_start":1,"highlight_end":43},{"text":"                            #[allow(deprecated)]","highlight_start":1,"highlight_end":49},{"text":"                            #[inline]","highlight_start":1,"highlight_end":38},{"text":"                            $(? #[$attr $($args)*])*","highlight_start":1,"highlight_end":53},{"text":"                            fn $Flag(&self) -> bool {","highlight_start":1,"highlight_end":54},{"text":"                                if Self::$Flag.bits == 0 && self.bits != 0 {","highlight_start":1,"highlight_end":77},{"text":"                                    false","highlight_start":1,"highlight_end":42},{"text":"                                } else {","highlight_start":1,"highlight_end":41},{"text":"                                    self.bits & Self::$Flag.bits == Self::$Flag.bits","highlight_start":1,"highlight_end":85},{"text":"                                }","highlight_start":1,"highlight_end":34},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    )*","highlight_start":1,"highlight_end":23},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut first = true;","highlight_start":1,"highlight_end":38},{"text":"                $(","highlight_start":1,"highlight_end":19},{"text":"                    if <Self as __BitFlags>::$Flag(self) {","highlight_start":1,"highlight_end":59},{"text":"                        if !first {","highlight_start":1,"highlight_end":36},{"text":"                            f.write_str(\" | \")?;","highlight_start":1,"highlight_end":49},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                        first = false;","highlight_start":1,"highlight_end":39},{"text":"                        f.write_str($crate::_core::stringify!($Flag))?;","highlight_start":1,"highlight_end":72},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                )*","highlight_start":1,"highlight_end":19},{"text":"                let extra_bits = self.bits & !Self::all().bits();","highlight_start":1,"highlight_end":66},{"text":"                if extra_bits != 0 {","highlight_start":1,"highlight_end":37},{"text":"                    if !first {","highlight_start":1,"highlight_end":32},{"text":"                        f.write_str(\" | \")?;","highlight_start":1,"highlight_end":45},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    first = false;","highlight_start":1,"highlight_end":35},{"text":"                    f.write_str(\"0x\")?;","highlight_start":1,"highlight_end":40},{"text":"                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;","highlight_start":1,"highlight_end":72},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                if first {","highlight_start":1,"highlight_end":27},{"text":"                    f.write_str(\"(empty)\")?;","highlight_start":1,"highlight_end":45},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(())","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        impl $crate::_core::fmt::Binary for $BitFlags {","highlight_start":1,"highlight_end":56},{"text":"            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {","highlight_start":1,"highlight_end":97},{"text":"                $crate::_core::fmt::Binary::fmt(&self.bits, f)","highlight_start":1,"highlight_end":63},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        impl $crate::_core::fmt::Octal for $BitFlags {","highlight_start":1,"highlight_end":55},{"text":"            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {","highlight_start":1,"highlight_end":97},{"text":"                $crate::_core::fmt::Octal::fmt(&self.bits, f)","highlight_start":1,"highlight_end":62},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        impl $crate::_core::fmt::LowerHex for $BitFlags {","highlight_start":1,"highlight_end":58},{"text":"            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {","highlight_start":1,"highlight_end":97},{"text":"                $crate::_core::fmt::LowerHex::fmt(&self.bits, f)","highlight_start":1,"highlight_end":65},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        impl $crate::_core::fmt::UpperHex for $BitFlags {","highlight_start":1,"highlight_end":58},{"text":"            fn fmt(&self, f: &mut $crate::_core::fmt::Formatter) -> $crate::_core::fmt::Result {","highlight_start":1,"highlight_end":97},{"text":"                $crate::_core::fmt::UpperHex::fmt(&self.bits, f)","highlight_start":1,"highlight_end":65},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        #[allow(dead_code)]","highlight_start":1,"highlight_end":28},{"text":"        impl $BitFlags {","highlight_start":1,"highlight_end":25},{"text":"            $(","highlight_start":1,"highlight_end":15},{"text":"                $(#[$attr $($args)*])*","highlight_start":1,"highlight_end":39},{"text":"                pub const $Flag: Self = Self { bits: $value };","highlight_start":1,"highlight_end":63},{"text":"            )*","highlight_start":1,"highlight_end":15},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Returns an empty set of flags.","highlight_start":1,"highlight_end":47},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            pub const fn empty() -> Self {","highlight_start":1,"highlight_end":43},{"text":"                Self { bits: 0 }","highlight_start":1,"highlight_end":33},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Returns the set containing all flags.","highlight_start":1,"highlight_end":54},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            pub const fn all() -> Self {","highlight_start":1,"highlight_end":41},{"text":"                __impl_all_bitflags! {","highlight_start":1,"highlight_end":39},{"text":"                    $BitFlags: $T {","highlight_start":1,"highlight_end":36},{"text":"                        $(","highlight_start":1,"highlight_end":27},{"text":"                            $(#[$attr $($args)*])*","highlight_start":1,"highlight_end":51},{"text":"                            $Flag = $value;","highlight_start":1,"highlight_end":44},{"text":"                        )*","highlight_start":1,"highlight_end":27},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Returns the raw value of the flags currently stored.","highlight_start":1,"highlight_end":69},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            pub const fn bits(&self) -> $T {","highlight_start":1,"highlight_end":45},{"text":"                self.bits","highlight_start":1,"highlight_end":26},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Convert from underlying bit representation, unless that","highlight_start":1,"highlight_end":72},{"text":"            /// representation contains bits that do not correspond to a flag.","highlight_start":1,"highlight_end":79},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {","highlight_start":1,"highlight_end":86},{"text":"                if (bits & !Self::all().bits()) == 0 {","highlight_start":1,"highlight_end":55},{"text":"                    $crate::_core::option::Option::Some(Self { bits })","highlight_start":1,"highlight_end":71},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    $crate::_core::option::Option::None","highlight_start":1,"highlight_end":56},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Convert from underlying bit representation, dropping any bits","highlight_start":1,"highlight_end":78},{"text":"            /// that do not correspond to flags.","highlight_start":1,"highlight_end":49},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            pub const fn from_bits_truncate(bits: $T) -> Self {","highlight_start":1,"highlight_end":64},{"text":"                Self { bits: bits & Self::all().bits }","highlight_start":1,"highlight_end":55},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Convert from underlying bit representation, preserving all","highlight_start":1,"highlight_end":75},{"text":"            /// bits (even those not corresponding to a defined flag).","highlight_start":1,"highlight_end":71},{"text":"            ///","highlight_start":1,"highlight_end":16},{"text":"            /// # Safety","highlight_start":1,"highlight_end":25},{"text":"            ///","highlight_start":1,"highlight_end":16},{"text":"            /// The caller of the `bitflags!` macro can chose to allow or","highlight_start":1,"highlight_end":74},{"text":"            /// disallow extra bits for their bitflags type.","highlight_start":1,"highlight_end":61},{"text":"            ///","highlight_start":1,"highlight_end":16},{"text":"            /// The caller of `from_bits_unchecked()` has to ensure that","highlight_start":1,"highlight_end":73},{"text":"            /// all bits correspond to a defined flag or that extra bits","highlight_start":1,"highlight_end":73},{"text":"            /// are valid for this bitflags type.","highlight_start":1,"highlight_end":50},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {","highlight_start":1,"highlight_end":72},{"text":"                Self { bits }","highlight_start":1,"highlight_end":30},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Returns `true` if no flags are currently stored.","highlight_start":1,"highlight_end":65},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            pub const fn is_empty(&self) -> bool {","highlight_start":1,"highlight_end":51},{"text":"                self.bits() == Self::empty().bits()","highlight_start":1,"highlight_end":52},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Returns `true` if all flags are currently set.","highlight_start":1,"highlight_end":63},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            pub const fn is_all(&self) -> bool {","highlight_start":1,"highlight_end":49},{"text":"                Self::all().bits | self.bits == self.bits","highlight_start":1,"highlight_end":58},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Returns `true` if there are flags common to both `self` and `other`.","highlight_start":1,"highlight_end":85},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            pub const fn intersects(&self, other: Self) -> bool {","highlight_start":1,"highlight_end":66},{"text":"                !(Self { bits: self.bits & other.bits}).is_empty()","highlight_start":1,"highlight_end":67},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Returns `true` if all of the flags in `other` are contained within `self`.","highlight_start":1,"highlight_end":91},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            pub const fn contains(&self, other: Self) -> bool {","highlight_start":1,"highlight_end":64},{"text":"                (self.bits & other.bits) == other.bits","highlight_start":1,"highlight_end":55},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Inserts the specified flags in-place.","highlight_start":1,"highlight_end":54},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            pub fn insert(&mut self, other: Self) {","highlight_start":1,"highlight_end":52},{"text":"                self.bits |= other.bits;","highlight_start":1,"highlight_end":41},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Removes the specified flags in-place.","highlight_start":1,"highlight_end":54},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            pub fn remove(&mut self, other: Self) {","highlight_start":1,"highlight_end":52},{"text":"                self.bits &= !other.bits;","highlight_start":1,"highlight_end":42},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Toggles the specified flags in-place.","highlight_start":1,"highlight_end":54},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            pub fn toggle(&mut self, other: Self) {","highlight_start":1,"highlight_end":52},{"text":"                self.bits ^= other.bits;","highlight_start":1,"highlight_end":41},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Inserts or removes the specified flags depending on the passed value.","highlight_start":1,"highlight_end":86},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            pub fn set(&mut self, other: Self, value: bool) {","highlight_start":1,"highlight_end":62},{"text":"                if value {","highlight_start":1,"highlight_end":27},{"text":"                    self.insert(other);","highlight_start":1,"highlight_end":40},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    self.remove(other);","highlight_start":1,"highlight_end":40},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Returns the intersection between the flags in `self` and","highlight_start":1,"highlight_end":73},{"text":"            /// `other`.","highlight_start":1,"highlight_end":25},{"text":"            ///","highlight_start":1,"highlight_end":16},{"text":"            /// Specifically, the returned set contains only the flags which are","highlight_start":1,"highlight_end":81},{"text":"            /// present in *both* `self` *and* `other`.","highlight_start":1,"highlight_end":56},{"text":"            ///","highlight_start":1,"highlight_end":16},{"text":"            /// This is equivalent to using the `&` operator (e.g.","highlight_start":1,"highlight_end":67},{"text":"            /// [`ops::BitAnd`]), as in `flags & other`.","highlight_start":1,"highlight_end":57},{"text":"            ///","highlight_start":1,"highlight_end":16},{"text":"            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html","highlight_start":1,"highlight_end":85},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            #[must_use]","highlight_start":1,"highlight_end":24},{"text":"            pub const fn intersection(self, other: Self) -> Self {","highlight_start":1,"highlight_end":67},{"text":"                Self { bits: self.bits & other.bits }","highlight_start":1,"highlight_end":54},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Returns the union of between the flags in `self` and `other`.","highlight_start":1,"highlight_end":78},{"text":"            ///","highlight_start":1,"highlight_end":16},{"text":"            /// Specifically, the returned set contains all flags which are","highlight_start":1,"highlight_end":76},{"text":"            /// present in *either* `self` *or* `other`, including any which are","highlight_start":1,"highlight_end":81},{"text":"            /// present in both (see [`Self::symmetric_difference`] if that","highlight_start":1,"highlight_end":76},{"text":"            /// is undesirable).","highlight_start":1,"highlight_end":33},{"text":"            ///","highlight_start":1,"highlight_end":16},{"text":"            /// This is equivalent to using the `|` operator (e.g.","highlight_start":1,"highlight_end":67},{"text":"            /// [`ops::BitOr`]), as in `flags | other`.","highlight_start":1,"highlight_end":56},{"text":"            ///","highlight_start":1,"highlight_end":16},{"text":"            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html","highlight_start":1,"highlight_end":83},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            #[must_use]","highlight_start":1,"highlight_end":24},{"text":"            pub const fn union(self, other: Self) -> Self {","highlight_start":1,"highlight_end":60},{"text":"                Self { bits: self.bits | other.bits }","highlight_start":1,"highlight_end":54},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Returns the difference between the flags in `self` and `other`.","highlight_start":1,"highlight_end":80},{"text":"            ///","highlight_start":1,"highlight_end":16},{"text":"            /// Specifically, the returned set contains all flags present in","highlight_start":1,"highlight_end":77},{"text":"            /// `self`, except for the ones present in `other`.","highlight_start":1,"highlight_end":64},{"text":"            ///","highlight_start":1,"highlight_end":16},{"text":"            /// It is also conceptually equivalent to the \"bit-clear\" operation:","highlight_start":1,"highlight_end":81},{"text":"            /// `flags & !other` (and this syntax is also supported).","highlight_start":1,"highlight_end":70},{"text":"            ///","highlight_start":1,"highlight_end":16},{"text":"            /// This is equivalent to using the `-` operator (e.g.","highlight_start":1,"highlight_end":67},{"text":"            /// [`ops::Sub`]), as in `flags - other`.","highlight_start":1,"highlight_end":54},{"text":"            ///","highlight_start":1,"highlight_end":16},{"text":"            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html","highlight_start":1,"highlight_end":79},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            #[must_use]","highlight_start":1,"highlight_end":24},{"text":"            pub const fn difference(self, other: Self) -> Self {","highlight_start":1,"highlight_end":65},{"text":"                Self { bits: self.bits & !other.bits }","highlight_start":1,"highlight_end":55},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Returns the [symmetric difference][sym-diff] between the flags","highlight_start":1,"highlight_end":79},{"text":"            /// in `self` and `other`.","highlight_start":1,"highlight_end":39},{"text":"            ///","highlight_start":1,"highlight_end":16},{"text":"            /// Specifically, the returned set contains the flags present which","highlight_start":1,"highlight_end":80},{"text":"            /// are present in `self` or `other`, but that are not present in","highlight_start":1,"highlight_end":78},{"text":"            /// both. Equivalently, it contains the flags present in *exactly","highlight_start":1,"highlight_end":78},{"text":"            /// one* of the sets `self` and `other`.","highlight_start":1,"highlight_end":53},{"text":"            ///","highlight_start":1,"highlight_end":16},{"text":"            /// This is equivalent to using the `^` operator (e.g.","highlight_start":1,"highlight_end":67},{"text":"            /// [`ops::BitXor`]), as in `flags ^ other`.","highlight_start":1,"highlight_end":57},{"text":"            ///","highlight_start":1,"highlight_end":16},{"text":"            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference","highlight_start":1,"highlight_end":79},{"text":"            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html","highlight_start":1,"highlight_end":85},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            #[must_use]","highlight_start":1,"highlight_end":24},{"text":"            pub const fn symmetric_difference(self, other: Self) -> Self {","highlight_start":1,"highlight_end":75},{"text":"                Self { bits: self.bits ^ other.bits }","highlight_start":1,"highlight_end":54},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Returns the complement of this set of flags.","highlight_start":1,"highlight_end":61},{"text":"            ///","highlight_start":1,"highlight_end":16},{"text":"            /// Specifically, the returned set contains all the flags which are","highlight_start":1,"highlight_end":80},{"text":"            /// not set in `self`, but which are allowed for this type.","highlight_start":1,"highlight_end":72},{"text":"            ///","highlight_start":1,"highlight_end":16},{"text":"            /// Alternatively, it can be thought of as the set difference","highlight_start":1,"highlight_end":74},{"text":"            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)","highlight_start":1,"highlight_end":79},{"text":"            ///","highlight_start":1,"highlight_end":16},{"text":"            /// This is equivalent to using the `!` operator (e.g.","highlight_start":1,"highlight_end":67},{"text":"            /// [`ops::Not`]), as in `!flags`.","highlight_start":1,"highlight_end":47},{"text":"            ///","highlight_start":1,"highlight_end":16},{"text":"            /// [`Self::all()`]: Self::all","highlight_start":1,"highlight_end":43},{"text":"            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html","highlight_start":1,"highlight_end":79},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            #[must_use]","highlight_start":1,"highlight_end":24},{"text":"            pub const fn complement(self) -> Self {","highlight_start":1,"highlight_end":52},{"text":"                Self::from_bits_truncate(!self.bits)","highlight_start":1,"highlight_end":53},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl $crate::_core::ops::BitOr for $BitFlags {","highlight_start":1,"highlight_end":55},{"text":"            type Output = Self;","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Returns the union of the two sets of flags.","highlight_start":1,"highlight_end":60},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            fn bitor(self, other: $BitFlags) -> Self {","highlight_start":1,"highlight_end":55},{"text":"                Self { bits: self.bits | other.bits }","highlight_start":1,"highlight_end":54},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl $crate::_core::ops::BitOrAssign for $BitFlags {","highlight_start":1,"highlight_end":61},{"text":"            /// Adds the set of flags.","highlight_start":1,"highlight_end":39},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            fn bitor_assign(&mut self, other: Self) {","highlight_start":1,"highlight_end":54},{"text":"                self.bits |= other.bits;","highlight_start":1,"highlight_end":41},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl $crate::_core::ops::BitXor for $BitFlags {","highlight_start":1,"highlight_end":56},{"text":"            type Output = Self;","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Returns the left flags, but with all the right flags toggled.","highlight_start":1,"highlight_end":78},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            fn bitxor(self, other: Self) -> Self {","highlight_start":1,"highlight_end":51},{"text":"                Self { bits: self.bits ^ other.bits }","highlight_start":1,"highlight_end":54},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl $crate::_core::ops::BitXorAssign for $BitFlags {","highlight_start":1,"highlight_end":62},{"text":"            /// Toggles the set of flags.","highlight_start":1,"highlight_end":42},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            fn bitxor_assign(&mut self, other: Self) {","highlight_start":1,"highlight_end":55},{"text":"                self.bits ^= other.bits;","highlight_start":1,"highlight_end":41},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl $crate::_core::ops::BitAnd for $BitFlags {","highlight_start":1,"highlight_end":56},{"text":"            type Output = Self;","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Returns the intersection between the two sets of flags.","highlight_start":1,"highlight_end":72},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            fn bitand(self, other: Self) -> Self {","highlight_start":1,"highlight_end":51},{"text":"                Self { bits: self.bits & other.bits }","highlight_start":1,"highlight_end":54},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl $crate::_core::ops::BitAndAssign for $BitFlags {","highlight_start":1,"highlight_end":62},{"text":"            /// Disables all flags disabled in the set.","highlight_start":1,"highlight_end":56},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            fn bitand_assign(&mut self, other: Self) {","highlight_start":1,"highlight_end":55},{"text":"                self.bits &= other.bits;","highlight_start":1,"highlight_end":41},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl $crate::_core::ops::Sub for $BitFlags {","highlight_start":1,"highlight_end":53},{"text":"            type Output = Self;","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Returns the set difference of the two sets of flags.","highlight_start":1,"highlight_end":69},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            fn sub(self, other: Self) -> Self {","highlight_start":1,"highlight_end":48},{"text":"                Self { bits: self.bits & !other.bits }","highlight_start":1,"highlight_end":55},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl $crate::_core::ops::SubAssign for $BitFlags {","highlight_start":1,"highlight_end":59},{"text":"            /// Disables all flags enabled in the set.","highlight_start":1,"highlight_end":55},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            fn sub_assign(&mut self, other: Self) {","highlight_start":1,"highlight_end":52},{"text":"                self.bits &= !other.bits;","highlight_start":1,"highlight_end":42},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl $crate::_core::ops::Not for $BitFlags {","highlight_start":1,"highlight_end":53},{"text":"            type Output = Self;","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Returns the complement of this set of flags.","highlight_start":1,"highlight_end":61},{"text":"            #[inline]","highlight_start":1,"highlight_end":22},{"text":"            fn not(self) -> Self {","highlight_start":1,"highlight_end":35},{"text":"                Self { bits: !self.bits } & Self::all()","highlight_start":1,"highlight_end":56},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl $crate::_core::iter::Extend<$BitFlags> for $BitFlags {","highlight_start":1,"highlight_end":68},{"text":"            fn extend<T: $crate::_core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {","highlight_start":1,"highlight_end":97},{"text":"                for item in iterator {","highlight_start":1,"highlight_end":39},{"text":"                    self.insert(item)","highlight_start":1,"highlight_end":38},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl $crate::_core::iter::FromIterator<$BitFlags> for $BitFlags {","highlight_start":1,"highlight_end":74},{"text":"            fn from_iter<T: $crate::_core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {","highlight_start":1,"highlight_end":97},{"text":"                let mut result = Self::empty();","highlight_start":1,"highlight_end":48},{"text":"                result.extend(iterator);","highlight_start":1,"highlight_end":41},{"text":"                result","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // Every attribute that the user writes on a const is applied to the","highlight_start":1,"highlight_end":73},{"text":"    // corresponding const that we generate, but within the implementation of","highlight_start":1,"highlight_end":78},{"text":"    // Debug and all() we want to ignore everything but #[cfg] attributes. In","highlight_start":1,"highlight_end":78},{"text":"    // particular, including a #[deprecated] attribute on those items would fail","highlight_start":1,"highlight_end":81},{"text":"    // to compile.","highlight_start":1,"highlight_end":19},{"text":"    // https://github.com/bitflags/bitflags/issues/109","highlight_start":1,"highlight_end":55},{"text":"    //","highlight_start":1,"highlight_end":7},{"text":"    // Input:","highlight_start":1,"highlight_end":14},{"text":"    //","highlight_start":1,"highlight_end":7},{"text":"    //     ? #[cfg(feature = \"advanced\")]","highlight_start":1,"highlight_end":42},{"text":"    //     ? #[deprecated(note = \"Use something else.\")]","highlight_start":1,"highlight_end":57},{"text":"    //     ? #[doc = r\"High quality documentation.\"]","highlight_start":1,"highlight_end":53},{"text":"    //     fn f() -> i32 { /* ... */ }","highlight_start":1,"highlight_end":39},{"text":"    //","highlight_start":1,"highlight_end":7},{"text":"    // Output:","highlight_start":1,"highlight_end":15},{"text":"    //","highlight_start":1,"highlight_end":7},{"text":"    //     #[cfg(feature = \"advanced\")]","highlight_start":1,"highlight_end":40},{"text":"    //     fn f() -> i32 { /* ... */ }","highlight_start":1,"highlight_end":39},{"text":"    (","highlight_start":1,"highlight_end":6},{"text":"        $(#[$filtered:meta])*","highlight_start":1,"highlight_end":30},{"text":"        ? #[cfg $($cfgargs:tt)*]","highlight_start":1,"highlight_end":33},{"text":"        $(? #[$rest:ident $($restargs:tt)*])*","highlight_start":1,"highlight_end":46},{"text":"        fn $($item:tt)*","highlight_start":1,"highlight_end":24},{"text":"    ) => {","highlight_start":1,"highlight_end":11},{"text":"        __impl_bitflags! {","highlight_start":1,"highlight_end":27},{"text":"            $(#[$filtered])*","highlight_start":1,"highlight_end":29},{"text":"            #[cfg $($cfgargs)*]","highlight_start":1,"highlight_end":32},{"text":"            $(? #[$rest $($restargs)*])*","highlight_start":1,"highlight_end":41},{"text":"            fn $($item)*","highlight_start":1,"highlight_end":25},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    (","highlight_start":1,"highlight_end":6},{"text":"        $(#[$filtered:meta])*","highlight_start":1,"highlight_end":30},{"text":"        // $next != `cfg`","highlight_start":1,"highlight_end":26},{"text":"        ? #[$next:ident $($nextargs:tt)*]","highlight_start":1,"highlight_end":42},{"text":"        $(? #[$rest:ident $($restargs:tt)*])*","highlight_start":1,"highlight_end":46},{"text":"        fn $($item:tt)*","highlight_start":1,"highlight_end":24},{"text":"    ) => {","highlight_start":1,"highlight_end":11},{"text":"        __impl_bitflags! {","highlight_start":1,"highlight_end":27},{"text":"            $(#[$filtered])*","highlight_start":1,"highlight_end":29},{"text":"            // $next filtered out","highlight_start":1,"highlight_end":34},{"text":"            $(? #[$rest $($restargs)*])*","highlight_start":1,"highlight_end":41},{"text":"            fn $($item)*","highlight_start":1,"highlight_end":25},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    (","highlight_start":1,"highlight_end":6},{"text":"        $(#[$filtered:meta])*","highlight_start":1,"highlight_end":30},{"text":"        fn $($item:tt)*","highlight_start":1,"highlight_end":24},{"text":"    ) => {","highlight_start":1,"highlight_end":11},{"text":"        $(#[$filtered])*","highlight_start":1,"highlight_end":25},{"text":"        fn $($item)*","highlight_start":1,"highlight_end":21},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // Every attribute that the user writes on a const is applied to the","highlight_start":1,"highlight_end":73},{"text":"    // corresponding const that we generate, but within the implementation of","highlight_start":1,"highlight_end":78},{"text":"    // Debug and all() we want to ignore everything but #[cfg] attributes. In","highlight_start":1,"highlight_end":78},{"text":"    // particular, including a #[deprecated] attribute on those items would fail","highlight_start":1,"highlight_end":81},{"text":"    // to compile.","highlight_start":1,"highlight_end":19},{"text":"    // https://github.com/bitflags/bitflags/issues/109","highlight_start":1,"highlight_end":55},{"text":"    //","highlight_start":1,"highlight_end":7},{"text":"    // const version","highlight_start":1,"highlight_end":21},{"text":"    //","highlight_start":1,"highlight_end":7},{"text":"    // Input:","highlight_start":1,"highlight_end":14},{"text":"    //","highlight_start":1,"highlight_end":7},{"text":"    //     ? #[cfg(feature = \"advanced\")]","highlight_start":1,"highlight_end":42},{"text":"    //     ? #[deprecated(note = \"Use something else.\")]","highlight_start":1,"highlight_end":57},{"text":"    //     ? #[doc = r\"High quality documentation.\"]","highlight_start":1,"highlight_end":53},{"text":"    //     const f: i32 { /* ... */ }","highlight_start":1,"highlight_end":38},{"text":"    //","highlight_start":1,"highlight_end":7},{"text":"    // Output:","highlight_start":1,"highlight_end":15},{"text":"    //","highlight_start":1,"highlight_end":7},{"text":"    //     #[cfg(feature = \"advanced\")]","highlight_start":1,"highlight_end":40},{"text":"    //     const f: i32 { /* ... */ }","highlight_start":1,"highlight_end":38},{"text":"    (","highlight_start":1,"highlight_end":6},{"text":"        $(#[$filtered:meta])*","highlight_start":1,"highlight_end":30},{"text":"        ? #[cfg $($cfgargs:tt)*]","highlight_start":1,"highlight_end":33},{"text":"        $(? #[$rest:ident $($restargs:tt)*])*","highlight_start":1,"highlight_end":46},{"text":"        const $($item:tt)*","highlight_start":1,"highlight_end":27},{"text":"    ) => {","highlight_start":1,"highlight_end":11},{"text":"        __impl_bitflags! {","highlight_start":1,"highlight_end":27},{"text":"            $(#[$filtered])*","highlight_start":1,"highlight_end":29},{"text":"            #[cfg $($cfgargs)*]","highlight_start":1,"highlight_end":32},{"text":"            $(? #[$rest $($restargs)*])*","highlight_start":1,"highlight_end":41},{"text":"            const $($item)*","highlight_start":1,"highlight_end":28},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    (","highlight_start":1,"highlight_end":6},{"text":"        $(#[$filtered:meta])*","highlight_start":1,"highlight_end":30},{"text":"        // $next != `cfg`","highlight_start":1,"highlight_end":26},{"text":"        ? #[$next:ident $($nextargs:tt)*]","highlight_start":1,"highlight_end":42},{"text":"        $(? #[$rest:ident $($restargs:tt)*])*","highlight_start":1,"highlight_end":46},{"text":"        const $($item:tt)*","highlight_start":1,"highlight_end":27},{"text":"    ) => {","highlight_start":1,"highlight_end":11},{"text":"        __impl_bitflags! {","highlight_start":1,"highlight_end":27},{"text":"            $(#[$filtered])*","highlight_start":1,"highlight_end":29},{"text":"            // $next filtered out","highlight_start":1,"highlight_end":34},{"text":"            $(? #[$rest $($restargs)*])*","highlight_start":1,"highlight_end":41},{"text":"            const $($item)*","highlight_start":1,"highlight_end":28},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    (","highlight_start":1,"highlight_end":6},{"text":"        $(#[$filtered:meta])*","highlight_start":1,"highlight_end":30},{"text":"        const $($item:tt)*","highlight_start":1,"highlight_end":27},{"text":"    ) => {","highlight_start":1,"highlight_end":11},{"text":"        $(#[$filtered])*","highlight_start":1,"highlight_end":25},{"text":"        const $($item)*","highlight_start":1,"highlight_end":24},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"see issue #49146 <https://github.com/rust-lang/rust/issues/49146> for more information","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0658]\u001b[0m\u001b[0m\u001b[1m: `if` is not allowed in a `const fn`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/png-0.16.8/src/common.rs:409:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m409\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mbitflags! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m410\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// # Output transformations\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m411\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ///\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m412\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// Only `IDENTITY` and `TRANSFORM_EXPAND | TRANSFORM_STRIP_ALPHA` can be used at the moment.\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m446\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m447\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: see issue #49146 <https://github.com/rust-lang/rust/issues/49146> for more information\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"aborting due to previous error","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to previous error\u001b[0m\n\n"}
{"message":"For more information about this error, try `rustc --explain E0658`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about this error, try `rustc --explain E0658`.\u001b[0m\n"}
